---
title: 面試紀錄
subtitle:
date: 2024-03-28T22:52:51+08:00
slug: 3a72038
draft: false
author:
  name:
  link:
  email:
  avatar:
description:
keywords:
license:
comment: false
weight: 0
tags:
  - 面試
categories:
  - DevOps
hiddenFromHomePage: false
hiddenFromSearch: false
hiddenFromRss: false
hiddenFromRelated: false
summary:
resources:
  - name: featured-image
    src: featured-image.jpg
  - name: featured-image-preview
    src: featured-image-preview.jpg
toc: true
math: false
lightgallery: false
password:
message:
repost:
  enable: true
  url:

# See details front matter: https://fixit.lruihao.cn/documentation/content-management/introduction/#front-matter
---
## ulimit

在 ulimit 中，有兩個重要的限制值，分別是 "soft" 和 "hard" 限制。這兩者之間的差異在於其影響範圍和設定權限：

1. Soft Limit（軟限制）：

軟限制是關於資源限制的初始值，用戶或進程可以自行提高軟限制，但不能超過硬限制。
用戶或進程可以通過 ulimit -S 命令提高軟限制。軟限制一般用於定義當前會話或進程的初始限制值。
用戶或進程通常有權修改或提高自己的軟限制，但不能超過相對應的硬限制。

2. Hard Limit（硬限制）：

硬限制是關於資源限制的最大允許值，它設定了軟限制的上限。硬限制通常由系統管理員設定，用戶或進程無法超過這個值。
用戶或進程通常無權修改硬限制。只有系統管理員可以提高硬限制，以使其大於或等於軟限制。
總之，軟限制是用戶或進程可以自行修改的初始限制值，而硬限制是這些軟限制的上限，只有系統管理員可以修改硬限制。這種設計允許用戶在合理的範圍內自行調整資源限制，同時確保系統管理員可以防止過度使用資源。

## git

Git中的Merge和Rebase是两种常用的代码合并策略，它们有一些重要的区别：

Merge（合并）：

Merge是将两个分支的历史记录合并在一起，创建一个新的合并提交（Merge commit）。在合并提交中，Git会保留各个分支的历史记录，并创建一个新的提交，将两个分支的更改合并在一起。
Merge会保留原始分支的提交历史，因此在提交图中会产生分叉。
Merge通常用于合并两个并行开发的分支，保留各自的提交历史，并创建一个合并点。
Rebase（变基）：

Rebase是将当前分支的提交移动到目标分支的最新提交之后，然后将目标分支的最新提交应用到当前分支上。换句话说，它会改变提交的基础，使得提交历史线性化。
Rebase会将当前分支的提交“重放”在目标分支的顶端，不会产生合并提交。因此，提交历史会变得更加清晰和线性。
Rebase通常用于保持提交历史的整洁和线性，避免产生不必要的合并提交。它也可以用于将一个分支的更改整合到另一个分支上，并保持提交历史的整洁。

## Docker 

    Docker 提供了不同类型的网络模式，允许容器与主机和其他容 器之间进行通信。以下是 Docker 中三种常见的网络模式： bridge、host 和 none。

  Bridge（桥接模式）：

  桥接模式是 Docker 的默认网络模式。
  在这种模式下，每个容器都分配了一个独立的 IP 地址，并与宿主  机上的一个虚拟网桥（Docker0）连接。
  容器之间可以相互通信，但它们的通信是通过网络地址转换  （NAT）进行的，它们的 IP 地址是隐藏的。
  这种模式适用于大多数应用，它提供了网络隔离和适度的安全性。
  Host（主机模式）：

  在主机模式下，容器与宿主机共享同一个网络栈，它们使用宿主机  的 IP 地址。
  这意味着容器可以直接访问宿主机上的网络服务，而无需进行端口  映射或地址转换。
  主机模式在某些性能敏感的应用场景中非常有用，但可能会降低容  器之间的隔离性。
  None（无网络模式）：

  在无网络模式下，容器不会分配任何网络接口或 IP 地址。
  这意味着容器与外部网络隔离，并且只能通过其他方式与它们进行  通信，例如进程间通信（IPC）或挂载宿主机的网络命名空间。
  无网络模式通常用于特殊情况，其中容器不需要网络连接。
  每种网络模式都适用于不同的使用情况，根据应用程序的需求选择  合适的网络模式非常重要。大多数情况下，使用桥接模式即可满足  容器的网络通信需求，但在特殊情况下，例如需要与宿主机共享网  络栈的高性能应用，可以考虑使用主机模式。无网络模式则用于极  少数情况，其中容器需要完全隔离的网络环境。

## TCP

TCP三次握手可以比喻成现实生活中的两个人建立通信连接的方式，他们想要确保能够顺畅地进行对话。以下是一个类比示例：

两位友人的电话通话：

第一步 - 打电话： 假设有两位友人，Alice 和 Bob，他们想要通过电话进行交流。首先，Alice决定打电话给Bob，以建立通话。这就好比TCP的第一次握手，其中Alice向Bob发送一个请求，表示她想要与Bob建立连接，就像发送了一个打电话的信号。

第二步 - 等待回应： Bob听到电话铃声，意识到有人想要与他通话。他决定接听电话，然后告诉Alice，他准备好与她交流。这就像TCP的第二次握手，其中Bob回应Alice的请求，表示他接受了连接，并准备好进行通信。

第三步 - 开始通话： 现在，Alice知道Bob已经准备好了，于是她们可以开始进行通话了。她告诉Bob，她愿意与他聊天，然后他们可以自由地交换信息和对话，就像在电话中交流一样。这就好比TCP的第三次握手，其中Alice发送了一个最后的确认，表示她已准备好与Bob进行通信。

这个类比可以帮助理解TCP三次握手的过程，其中两个通信方（Alice和Bob）确保他们都准备好建立通信连接，然后开始自由地交流信息。如果有任何一方在这个过程中出现问题，他们可以重新尝试建立连接，就像在电话通话中如果通话未能接通可以重新拨打电话一样。这个过程确保了可靠的通信连接的建立。
## OPTIONS
* RESTful API中的HTTP OPTIONS方法是一種用於獲取有關資源支援的通信選項的請求方法。它並不是用於檢索或更改實際資源數據的，而是用於查詢資源的元數據（metadata），如支援的HTTP方法、支援的標頭、支援的內容類型等。

以下是HTTP OPTIONS方法的主要用途：

獲取支援的HTTP方法：使用OPTIONS方法，客戶端可以查詢特定資源支援的HTTP方法，例如GET、POST、PUT、DELETE等。這有助於客戶端了解如何與資源進行交互。

查詢支援的標頭：OPTIONS請求還可以用於查詢資源支援的HTTP標頭，如Authorization、Accept、Content-Type等。這有助於客戶端確定可以使用哪些標頭來自定義請求。

確定資源的特性：OPTIONS請求還可用於獲取資源的其他特性，如資源的語言支援、允許的內容編碼、允許的跨域請求等。

跨域資源共享（CORS）：OPTIONS方法通常用於實現跨域資源共享（CORS），這是一個安全機制，允許網頁應用程序從不同的域名上請求資源。當瀏覽器向另一個域名的API發送請求時，瀏覽器首先使用OPTIONS方法發送預檢請求（preflight request），以確定伺服器是否支援跨域請求。

總之，HTTP OPTIONS方法用於查詢RESTful API資源的通信選項，包括支援的HTTP方法、支援的標頭和其他特性。它有助於客戶端確定如何正確地與資源進行互動，並在跨域請求時提供安全性檢查。

## Connection timeout vs connection refused
* "Connection timeout"（連接超時）和"Connection refused"（連接拒絕）是在網絡通信中經常遇到的兩種不同的錯誤狀態，它們之間有明顯的區別：

Connection Timeout（連接超時）：

當一個客戶端（例如瀏覽器、應用程序或服務）嘗試建立到伺服器的連接時，它會等待一段時間，如果在指定的時間內無法建立連接，就會發生連接超時。
連接超時通常表示客戶端在嘗試與伺服器建立連接時等待了過長的時間，但最終未能成功建立連接。
可能的原因包括伺服器故障、網絡問題、防火牆規則阻止連接等。
Connection Refused（連接拒絕）：

當一個客戶端嘗試與伺服器建立連接時，如果伺服器端不接受該連接請求，則會發生連接拒絕。
連接拒絕通常表示伺服器正在運行，但它拒絕了客戶端的連接請求。這可能是因為伺服器上未運行所需的服務，或者伺服器上的端口未被監聽。
通常，伺服器上的應用程序沒有在指定的端口上侦听连接，或者防火牆规则拒绝了连接。
總結來說，連接超時是當客戶端在嘗試建立連接時等待過長時間而導致的錯誤，而連接拒絕則是當伺服器端明確地拒絕了客戶端的連接請求。在故障排除和網絡連接問題時，了解這兩種錯誤的差異對確定問題的根本原因非常重要。

## Kubernetes中的同一個Pod中不同容器之間可以使用localhost來訪問彼此的主要原因是，它們共享相同的網絡命名空間（Network Namespace）和 IPC 命名空間（IPC Namespace）。

以下是詳細的解釋：

共享網絡命名空間：

在Kubernetes Pod中，所有容器共享相同的網絡命名空間。這意味著它們使用相同的網絡接口和IP地址，並可以直接通過localhost訪問對方。
因為它們處於同一個網絡命名空間，所以它們可以互相看到並通信，就像同一台主機上運行的進程一樣。
共享IPC命名空間：

同一個Pod中的容器也共享相同的IPC命名空間。這使得它們可以使用System V IPC和POSIX消息隊列等IPC機制來進行進程間通信。
這對於某些應用程序或服務可能是有用的，因為它們可以直接通信，而無需通過網絡進行。
總之，Kubernetes中的同一個Pod中的不同容器可以使用localhost來訪問彼此，是因為它們共享相同的網絡和IPC命名空間。這提供了容器之間方便的本地通信機制，同時保持了容器的隔離性。但請注意，這種本地通信僅限於同一個Pod中的容器，不同Pod中的容器仍需要使用網絡通信協議來進行互相通信。
<!--more-->
