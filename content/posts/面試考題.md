---
title: K8s相關問題
subtitle:
date: 2024-03-28T23:06:07+08:00
slug: 3ab3a5e
draft: true
author:
  name:
  link:
  email:
  avatar:
description:
keywords:
license:
comment: false
weight: 0
tags:
  - draft
categories:
  - draft
hiddenFromHomePage: false
hiddenFromSearch: false
hiddenFromRss: false
hiddenFromRelated: false
summary:
resources:
  - name: featured-image
    src: featured-image.jpg
  - name: featured-image-preview
    src: featured-image-preview.jpg
toc: true
math: false
lightgallery: false
password:
message:
repost:
  enable: true
  url:

# See details front matter: https://fixit.lruihao.cn/documentation/content-management/introduction/#front-matter
---
* kube-proxy 的角色包括（选择两个）：

维护节点上的网络规则（Maintains network rules on nodes）： kube-proxy负责维护节点上的网络规则，以确保流量正确路由到Pod。它管理网络地址转换（NAT）规则和端口映射，以便将请求路由到正确的Pod。

允许对Pod的网络通信（Allows network communication to pods）： kube-proxy允许外部流量访问Pod，并确保Pod之间的网络通信。它负责将服务的流量负载均衡到相应的Pod上，以实现服务发现和负载均衡。

kube-proxy并不是反向代理（reverse proxy），不会回答DNS查询，也不连接节点到控制平面。这些任务由其他组件来处理，例如CoreDNS和kubelet。

* 容器化的優勢
  减少开销（Reduces overhead）： 容器通常比虚拟机更轻量级，因此可以更有效地利用系统资源，减少了虚拟化带来的额外开销。

  导致更一致的运行（Leads to more consistent operation）： 容器化应用程序具有相同的运行环境，这使得它们在不同的部署中更具一致性，减少了配置和依赖问题。

  使应用程序更具可移植性（Makes applications more portable）： 容器可以在不同的环境中运行，包括开发、测试和生产环境，因此应用程序更容易移植和部署。

* Docker 卷 在linux 存儲在
  /var/lib/docker/volumes

* http 202 

  在云环境中运行异步作业时，用于确定成功作业提交的HTTP响应代码通常是 HTTP 202 Accepted。这个响应代码表示请求已被接受，并且作业将在稍后的时间内异步处理。这意味着作业成功提交到处理队列中。

* 高可用性
  以下特性使键值数据库具有高可用性（选择三个）：

  复制（Replication）： 复制是将数据副本分布到多个节点或服务器的过程。这确保了即使某个节点或服务器发生故障，仍然可以从其他节点获取数  据，从而提高了可用性。

  分片（Sharding）： 分片是将数据分为较小的块（分片），并将每个分片存储在不同的节点上。这有助于平衡负载和提高性能，同时减少了单一节 点的风险，从而提高了可用性。

  横向扩展（Scale out）： 键值数据库通常支持横向扩展，即添加更多的节点或服务器来处理更多的负载。这种扩展方式有助于提高系统的容量和可  用性。

* 将工作负载迁移到云与在本地部署相比有以下三个优势：

弹性（Elasticity）： 云计算允许根据需要扩展或缩减资源，以适应流量和负载的变化。这意味着您可以根据需求灵活地分配计算、存储和网络资源，而不必事先规划和购买大量硬件。

按需付费（Pay-as-you-go）： 云计算模型允许您根据实际资源使用情况付费，避免了昂贵的前期硬件投资。您只需支付您实际使用的计算和存储资源，这有助于降低成本。

减少基础设施关注（Less focus on infrastructure）： 在云中，云服务提供商负责管理基础设施的维护和更新，包括硬件、网络和数据中心。这意味着您可以将更多精力集中在应用程序开发和业务创新上，而不必担心基础设施的日常运营。

与之相反，本地部署通常需要进行前期基础设施预配（Upfront infrastructure provisioning）和预先计划容量（Pre-anticipated capacity），这可能导致资源浪费和较高的成本。

* 以下是描述键值数据库的特性（选取三个）：

分区容错（Partition tolerant）： 键值数据库通常具有分布式特性，能够容忍分区，即网络分区或某些节点不可用的情况。

高可用性（Highly available）： 键值数据库通常旨在保持高可用性，确保数据在系统中的可靠性和持续可访问性。

最终一致性（Eventual consistency）： 键值数据库通常采用最终一致性模型，这意味着在一段时间后，所有副本的数据将达到一致状态，即使在写入时可能存在一定程度的不一致。这种模型有助于提高性能和可用性。

与键值数据库不太相关的属性包括支持复杂联接（Supports complex joins）和有模式结构（Schema structure）。键值数据库通常不支持复杂的数据关联操作，也不依赖于固定的模式结构，因此更灵活适应不同的数据类型。

* 要解决 "打开文件过多" 错误，您可以采取以下两种方法：

使用 ulimit 命令： 使用 ulimit -n 和 ulimit -nH 命令可以查看和修改用户或进程的文件描述符限制。您可以通过增加限制的方式来增加允许打开的文件数量。

检查系统文件描述符上限： 使用 cat /proc/sys/fs/file-max 命令可以查看系统级别的文件描述符上限。如果这个值较低，您可以通过修改系统的文件描述符上限来增加允许打开的文

* 要解决 "打开文件过多" 错误，您可以采取以下两种方法：

增加文件描述符限制： 这可以通过修改系统的文件描述符限制来实现。在大多数Linux系统上，可以通过编辑 /etc/security/limits.conf 文件或 /etc/sysctl.conf 文件来增加文件描述符的限制。您可以设置更高的限制以容纳更多的打开文件。修改完限制后，通常需要重新启动系统以使更改生效。

关闭不必要的文件句柄： 这涉及到检查应用程序的代码和配置，确保在使用完文件后适当地关闭它们。确保您的代码中没有未关闭的文件句柄，以避免资源泄漏。可以使用工具如 lsof 来检查哪些文件被打开，以帮助确定问题所在。

* What commands summarize the count of network connections and their state? (Select Two.)

Netstat（netstat）：可以使用netstat命令来列出活动的网络连接以及其状态。例如，netstat -tuln 可以列出TCP和UDP连接的摘要信息。

ss：ss命令也用于显示套接字统计信息，包括网络连接计数和状态。例如，ss -tuln 可以列出TCP和UDP连接的摘要信息。

* 当主机在特定端口上未运行任何服务时，通常会显示 connection refused（连接被拒绝） 的消息。这表示主机已经能够接收连接请求，但没有运行任何服务来处理该端口上的请求。其他选项如"operation timedout"或"connection timedout"表示连接超时，而"connection failed"表示连接失败，通常与网络问题相关。"connection lost"表示连接丢失，通常发生在已经建立的连接中断时。


* 要在路由器上启用实时翻译查看，可以使用 debug ip nat 命令。这个命令启用了IP网络地址转换（NAT）的调试功能，允许您查看NAT翻译的详细信息，包括实时数据。
NAT - 了解 debug nat 詳細輸出
調試NATip debug nat detailed時，可以使用該指令 。將顯示類似以下內容的輸出：

Router# debug ip nat 詳細
NAT: i: udp (192.168.1.95, 1493) -> (172.31.2.132, 53) [22399]
NAT: o: udp (172.31.2.132, 53) -> (172.31.233.193, 1493) [63671]
NAT*: i: TCP (192.168.1.95, 1135) -> (172.31.2.75, 23) [22400]
NAT*: o: tcp (172.31.2.75, 23) -> (172.31.233.193, 1135) [22002]
NAT*: i: TCP (192.168.1.95, 1135) -> (172.31.2.75, 23) [22401]
NAT*: i: TCP (192.168.1.95, 1135) -> (172.31.2.75, 23) [22402]
NAT*: o: tcp (172.31.2.75, 23) -> (172.31.233.193, 1135) [22060]
NAT*: o: tcp (172.31.2.75, 23) -> (172.31.233.193, 1135) [22071]
括號內每個 IP 位址後面出現的值是傳輸層連接埠號碼。

第一個項目顯示DNS請求從內部主機發送到目標 172.31.2.132 和連接埠號碼 53，這是 DNS 服務的眾所周知的連接埠。
第三個條目顯示從內部主機到 172.31.2.75 的 Telnet 會話，目標連接埠號碼為 23，這是 Telnet 的眾所周知的連接埠。
末尾方括號中的值是封包中找到的 IP 標識號。標識欄位用於幫助 IP 封包分段和重組，但此處也用於允許將此偵錯資訊與其他封包追蹤和協定分析器相關聯。

* top 命令在监视系统性能时非常有用，其中包括 CPU 负载平均值（Load Average）。Load Average 是一个表示系统在一段时间内的负载情况的指标，通常以三个数字表示。这三个数字分别代表了最近 1 分钟、5 分钟和15 分钟的平均负载。它们的单位是进程队列的长度，可以理解为等待运行的进程数量。

下面是对 Load Average 指标中的每个部分的解释：

1 分钟平均负载：这个数字表示最近 1 分钟内系统上平均等待运行的进程数。如果这个数字越大，表示系统在短期内的负载较高。

5 分钟平均负载：这个数字表示最近 5 分钟内系统上平均等待运行的进程数。它提供了更长时间范围内的平均负载情况。如果这个数字持续较高，表示系统在中期内的负载也较高。

15 分钟平均负载：这个数字表示最近 15 分钟内系统上平均等待运行的进程数。它提供了更长时间范围内的平均负载情况，通常用于判断系统的长期性能。

通常情况下，Load Average 的值应该接近系统的 CPU 核心数量。例如，如果系统有 4 个 CPU 核心，那么理想情况下 Load Average 应该在 4 左右。如果 Load Average 显著高于 CPU 核心数量，表示系统负载较高，可能存在性能问题，需要进一步分析和优化。

Load Average 是一个重要的系统性能指标，可用于监视系统的负载情况，以便及时识别和解决性能问题。

* top 命令在监视系统性能时非常有用，其中包括 CPU 负载平均值（Load Average）。Load Average 是一个表示系统在一段时间内的负载情况的指标，通常以三个数字表示。这三个数字分别代表了最近 1 分钟、5 分钟和15 分钟的平均负载。它们的单位是进程队列的长度，可以理解为等待运行的进程数量。

下面是对 Load Average 指标中的每个部分的解释：

1 分钟平均负载：这个数字表示最近 1 分钟内系统上平均等待运行的进程数。如果这个数字越大，表示系统在短期内的负载较高。

5 分钟平均负载：这个数字表示最近 5 分钟内系统上平均等待运行的进程数。它提供了更长时间范围内的平均负载情况。如果这个数字持续较高，表示系统在中期内的负载也较高。

15 分钟平均负载：这个数字表示最近 15 分钟内系统上平均等待运行的进程数。它提供了更长时间范围内的平均负载情况，通常用于判断系统的长期性能。

通常情况下，Load Average 的值应该接近系统的 CPU 核心数量。例如，如果系统有 4 个 CPU 核心，那么理想情况下 Load Average 应该在 4 左右。如果 Load Average 显著高于 CPU 核心数量，表示系统负载较高，可能存在性能问题，需要进一步分析和优化。

Load Average 是一个重要的系统性能指标，可用于监视系统的负载情况，以便及时识别和解决性能问题。

* top 命令中的 RES（Resident Set Size）是一个表示进程当前占用的物理内存量的指标。RES 列显示的值通常以千字节（KB）或兆字节（MB）为单位。

下面是对 RES 列的解释：

RES（Resident Set Size）：这是指进程当前实际占用的物理内存量。它包括了进程使用的所有内存，包括代码、数据、共享库以及栈等。RES 列的值表示了进程在物理内存中的驻留部分，也就是当前正在使用的内存。
RES 列的值对于监视系统上各个进程的内存使用非常有用。通过查看 RES 列，您可以了解哪些进程占用了大量的物理内存，以及系统内存资源的分配情况。如果某个进程的 RES 值异常高，可能需要进一步分析和优化，以确保系统的内存资源得到合理利用，防止出现内存不足的问题。

请注意，RES 列显示的内存使用量是实际物理内存的占用，与虚拟内存或交换空间无关。因此，较高的 RES 值可能会导致系统内存压力较大，需要根据实际情况采取适当的措施来管理内存资源

* Docker 
  Docker 中的 "Single-host networking" 是指在单个 Docker 主机上管理容器之间的网络通信。它是 Docker 默认的网络模式，也被称为 "bridge mode"（桥接模式）或 "user-defined bridge mode"（用户自定义桥接模式）。

在 Single-host networking 模式下，Docker 主机上的所有容器都可以通过一个共享的桥接网络连接到主机和其他容器。每个容器都分配了一个唯一的 IP 地址，并且它们可以通过这些 IP 地址相互通信。此外，它们也可以通过主机的 IP 地址进行通信。

这个网络模式通常用于在单个主机上运行多个容器，使它们能够相互通信，并且可以访问主机上的外部资源，例如互联网或其他网络服务。这对于构建微服务应用程序、开发和测试容器化应用程序非常有用。

需要注意的是，Single-host networking 是 Docker 的默认网络模式，因此如果您不显式指定其他网络模式，容器将默认使用这种网络配置。如果需要更高级的网络配置，Docker 还支持其他网络模式，如 "overlay network"（覆盖网络）和 "macvlan" 等，用于跨多个 Docker 主机的容器通信。

* tcp 三次交握
  在TCP/IP协议中，TCP（传输控制协议）的连接建立通常需要经过一个三次握手（Three-Way Handshake）的过程。三次握手用于确保客户端和服  务器之间的连接是可靠的，并且双方都已准备好进行数据传输。以下是三次握手的过程：
  
  第一次握手（SYN）：客户端向服务器发送一个带有SYN（同步）标志的TCP数据包，表示客户端请求建立连接。这个数据包包含了客户端选择的一个 初始序列号。
  
  第二次握手（SYN-ACK）：服务器接收到客户端的SYN数据包后，会发送一个带有SYN和ACK（确认）标志的数据包给客户端，表示服务器已经接受了  连接请求，并准备好建立连接。这个数据包还包含了服务器选择的一个初始序列号。
  
  第三次握手（ACK）：客户端接收到服务器的SYN-ACK数据包后，会发送一个带有ACK标志的数据包给服务器，表示客户端确认连接已建立。服务器收 到这个确认后，连接就正式建立，双方可以开始进行数据传输。
  
  三次握手确保了双方都同意建立连接，并且在连接建立之前都可以交换序列号等必要的信息。这有助于防止无意义的连接或连接中的错误。一旦连接建  立，数据可以在客户端和服务器之间自由传输，直到连接被关闭。
<!--more-->
